Звіт з виконання лабораторної роботи №5-6  
=========================================

1. Завдання 
-----------

Метою даної лабораторної роботи було освоїти принцип роботи символьних прстроїв. Викладачем був наданий приклад, який треба було
модифікувати, а саме:

* замінити список асоціативнив масивом або деревом
* ініціалізувати пам'ять пристрою "нульовими" символами
* додати логіку зчитування та запису буферу пам'яті пристрою
* додати можливість керування пристроєм за допомогою ``ioctl``, а саме запис "магічної" фрази в буфер та можливість задання розміру буфера користувачем
* додати можливість самореєстрації пристрою в ``/dev``

2. Теоретичні відомості та реалізація
-------------------------------------

2.1. Character devive
"""""""""""""""""""""

Символьний пристрії, або **character device** - це такий пристрій, до якого можна звертатися як до потоку байтів(так як і до
файлу), драйвер символьного пристрою відповідає за реалізацію такої поведніки. Такий драйвер зазвичай підтримує такі системні 
виклики, як ``open()``, ``close()``, ``read()`` та ``write()``. Наприклад текстовий екран ``/dev/console`` або послідовні порти 
``/dev/ttyS0`` і т.д. являються прикладами символьних пристроїв, так як вони добре представлені абстракцією потоку. Для звернення до 
символьних пристроїв використовують вузли ``node`` файлової системи, наприклад такі як ``/dev/tty1`` і ``/dev/lp0``. Єдиною 
важливою відмінністю між символьними пристроями і звичайними файлами є те що по останніх можна рухатись як вперед так і назад, а
більшість символьних пристроїв представлені каналами до яких можна звертатись тільки послідовно. Однак існують такі символьні 
пристрої які виглядають як області даних, по яким можна рухатись назад і вперед, в приклад можна привести граббер екрану - 
додаток отримує доступ до всього зображення, використовуючи при цьому ``mmap`` та ``lseek``.

2.2. Major & minor
""""""""""""""""""

Для реєстрації пристрою потрібно задати спеціальні номери, а саме **major** та **minor**. Ці цифри являються старшим та молодшим 
номером пристрою для кожного з них. Традиційно, старший номер ідентифікує драйвер, асоційований з пристроєм. Наприклад 
``/dev/null`` і ``/dev/zero`` керуються драйвером 1, тоді як віртуальні консолі і послідовні термінали керуються драйвером 4.
Сучасні ядра Linux дозволяють декільком драйверам мати однакові старші номери, але більшість пристроїв організовані по принципу
один старший номер - один драйвер. молодший номер використовується ядром, для того щоб точно визначити пристрій, про який йде
мова.

2.3. Реалізація
"""""""""""""""

Тепер розглянемо покроковий механізм створення драйвера символьного пристрою. В першу чергу потрібно виділити один або декілька
номерів пристроїв для роботи з ними. Дану дію можна реалізувати за допомогою функції, яка об'явлена в ``<linux/fs.h>`` 

.. code-block:: c

  int register_chrdev_region(dev_t first, unsigned int count, char *name);
  
``first`` - це початок діапазону номерів, в більшості випадків це 0; 

``count`` - це загальна кількість суміжних номерів пристроїв;

``name`` - це ім'я пристрою, яке має бути звязано з цим діапазоном номерів.

У тому випадку коли невідомо які саме номери будуть використовуватись, потрібно використовувати іншу функцію, яка зробить це
динамічно, так би мовити ядро виділить старший номер для пристрою "на льоту".

.. code-block:: c

  int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned intcount, char *name);
  
``dev`` - це вхідне значення, яке при успішному завершенні містить перший номер виділеного діапазону;

``firstminor`` - містить значення першого молодшого номеру, зазвичай це 0;

Параметри ``count`` та ``name`` аналогічні з попередньою функцією. 

Незалежно від того як були назначені номери пристрою, потрібно звільнити їх якщо вони більше не використовуються. Це робиться за 
дпомогою функції 

.. code-block:: c

  void unregister_chrdev_region(dev_t first, unsigned int count);
  
Реєстарція номера пристрою являється лише першою із багатьох задач, які має виконувати код драйвера. Більшість основних операцій
драйвера включають три важливі стуктури даних ядра: ``file_operations``, ``file`` та ``inode``. Всі вони об'явлені в 
``<linux/fs.h>``

``file_operations`` - структура, яка встановлює зв'язок між драйверними операціями та номерами, які ми зареєстрували. 

``file`` - являється другою по важливості структурою і представляє відкритий файл. Вона створюється ядром при відкритті і 
передається в будь-яку функцію, яка працює з файлом, до останнього закриття. Після закриття всіх екземплярів файлу ядро звільняє
структуру даних.

``inode`` - так званий індексний дескриптор. Використовується ядром внутрішньо для представлення файлів. Тому вона відрізняється
від файлової структури, яка представляє відкритий файловий дескриптор. Найбільш нам цікаво одне поле цієї структури, а саме

.. code-block:: c

  struct cdev *i_cdev;

Дана стурктура являється внутрішньою структурою ядра, яка представляє символьні пристрої. Це поле містить вказівник на ту
структуру, де ``inode`` ссилається на файл символьного пристрою. 
Тепер щоб зареєструвати наш пристрій, спочатку треба проініціалізувати відповідні структури

.. code-block:: c

  void cdev_init(struct cdev *cdev, struct file_operations *fops);
  
Також структура ``cdev`` має поле ``owner`` яке потрібно встановити в ``THIS_MODULE``. І останнім кроком в створенні стурктури
``cdev`` - повідомити про це ядру викликом

.. code-block:: c

  int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
  
А для того щоб видалити символьний пристрій з системи використовується

.. code-block:: c

  void cdev_del(struct cdev *dev);

Для того щоб реалізувати можливість самореєстрації пристрою в ``/dev``, спочатку потрібно сворити клас пристрою за допмогою 
``class_create()``, а потім вже зареєструвати сам пристрій за допомогою ``device_create()``.

Тепер розглянемо логіку зчитування та запису пам'яті пристрою. Методи ``read`` та ``write`` представлені наступним чином

.. code-block:: c

  ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t*offp);
  ssize_t write(struct file *filp, const char __user *buff, size_t count,loff_t *offp);
  
Для обох методів ``flip`` являється вказівником на ``file``, ``count`` - це розмір запрошуваної передачі даних. Аргумент ``buff``
вказує на користувацький буфер даних(примітка - він не може бути безпосередньо розйменованим кодом ядра). ``offp`` являється
вказівником на обєкт, який вказує на позицію файла, до якої звертається користувач. 
Для того щоб скопіювати весь сегмент даних в або з адресного простору користувача, використовуються наступні функції ядра

.. code-block:: c

  unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);
  unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);
  
Тепер розглянемо механізм керування пристроєм. Зазвичай більшості драйверів в доповнення до можливості читання і запису необхідна
можливість керування апаратурою різними способами через драйвер пристрою. Такі операції зазвичай підримуються через метод
``ioctl``(команда управління вводом-виводом) який реалізує системний виклик з тією ж назвою. Метод драйвера ``ioctl`` має 
наступний прототип

.. code-block:: c

  long ioctl(struct file *f, unsigned int cmd, unsigned long arg);

Теоретичні дані були запозичені з книги **Jonathan Corbet, Alessandro Rubini, and Greg Kroah-Hartman, 
Linux Device Drivers. Third Edition**.

